import PyNexus as PN #use version >= 4.1

import matplotlib.pyplot as plt
from matplotlib.pyplot import cm
import matplotlib.colors as mplcolors
from matplotlib.ticker import FormatStrFormatter
import matplotlib.gridspec as gridspec

import numpy as np
from numpy import linalg
from math import isclose
from scipy.special import erfc
from lmfit import Minimizer, Parameters, fit_report, conf_interval, printfuncs

import sys
import os
import shutil
import csv

import base64
from IPython.display import clear_output, Javascript, display
import ipywidgets as widgets
try:
    import ipysheet
except:
    print('Careful: the module ipysheet is not installed!')

__version__="v1.0"


################ NOTEBOOK SELF-GENERATION ###########################

def print_version():
    print('Version FluoJupyter_functions: %s'%__version__)

def create_cell(code='', celltype='code', is_execute=False):
    """Create a cell in the IPython Notebook.
    code: unicode, Code to fill the new cell with.
    celltype: unicode, Type of cells "code" or "markdown".
    is_execute: boolean, Execute or not the cell after creation.
            """
    encoded_code = (base64.b64encode(code.encode())).decode()
    if is_execute:
        display(Javascript("""
        var code = IPython.notebook.insert_cell_at_bottom("{0}");
        code.set_text(atob("{1}"));
        code.execute();
        """.format(celltype, encoded_code)))
    else:
        display(Javascript("""
        var code = IPython.notebook.insert_cell_at_bottom("{0}");
        code.set_text(atob("{1}"));
        """.format(celltype, encoded_code)))

def generate_cells_on_click():
    """
    cells is an array of array used to create the predefined cells.
    Each array of cells should contain [code, celltype, is_execute]
    code is a string with the text/code to display in the cell
    celltype is a string, 'code' or 'markdown'
    is_execute is a boolean to tell if the cell should executed immediately after creation
    """

    cells = [
    ['# New experiment: replace by name', 'markdown', True],
    ['Describe the experiment here.', 'markdown', True],
    ['expmt = Experiment(dparams_general, dparams_fit)', 'code', True],
    ['## Peak definition', 'markdown', True],
    ['# Run this cell\n'+\
     'expmt.define_peaks()', 'code', False],
    ['# Run this cell\n'+\
     'expmt.extract_elems()\n'+\
     'w = widgets.interact(expmt.display_peaks,spectrum_index=widgets.IntText(value=0, step=1, description=\'Spectrum:\'))'\
     ,'code', False],
    ['## Fit the spectrums', 'markdown', True],
    ['# Run this cell\n'+\
     'expmt.fit_spectrums()', 'code', False],
    ['## Show the results on a given spectrum', 'markdown', True],
    ['# Run this cell\n'+\
     'w = widgets.interact(expmt.load_results,spectrum_index=widgets.IntText(value=0, step=1, description=\'Spectrum:\'),is_save = widgets.Checkbox(value=False, description=\'Save Fit?\'))'\
     ,'code', False],
    ['generate_cells_on_click()', 'code', True],
    ]

    def on_button_clicked(b):
        """Generate the cells when clicked"""

        for cell in cells:
            create_cell(code=cell[0], celltype=cell[1], is_execute = cell[2])

    layout = widgets.Layout(width='500px', height='40px')
    button = widgets.Button(description="Click me to create the next cells!", layout=layout)
    output = widgets.Output()

    display(button, output)
    button.on_click(on_button_clicked)


################ ANALYSIS ###########################

class Experiment:
    """
    Contains all the info and methods on the experiment analyzed.
    Description of the different dictionaries of parameters:
    Given by the expert:
    - dparams_general contains general parameters, such as is_ipysheet or gain
    - dparams_fit contains the fitting parameters common to the whole spectrum, such as fan or fG
    Generated by the program:
    - dparams_0 contains the initial guess for the LM fit
    - dparams_lm contains the current parameter set during the LM fit
    - dparams_list contains lists of results from the fits (one list per fit parameter)
    """

    def __init__(self, dparams_general, dparams_fit):

        # Expert parameters for the fit
        self.dparams_fit = dparams_fit

        # Expert parameters which are not fitting parameters,
        # Put them as attributes instead of dict
        for key, value in dparams_general.items():
            setattr(self, key, value)

        # Define experiment with the last created Fluo file from the current folder as the default value
        list_files = sorted(os.listdir())
        last_file = [file for file in list_files if 'Fluo' in file and 'nxs' in file][-1]
        self.define_experiment(file_default=last_file)

    def define_experiment(self, file_default):
        """
        1) Create widgets to allow for user to enter required params.
        2) Execute the spectrum extraction when clicking on the button.
        Take an optional default file name.
        """

        layout = widgets.Layout(width='500px', height='40px')
        style = {'description_width': 'initial'}

        wfile = widgets.Text(
            value=file_default,
            description='File Name:',
            layout=layout,
            style=style)

        wis_load =  widgets.Checkbox(
            value=True,
            description='Load the file?')

        wind_first_spectrum = widgets.IntText(
            value=self.ind_first_spectrum,
            step=1,
            description='First spectrum:',
            style=style)

        wind_last_spectrum = widgets.IntText(
            value=self.ind_last_spectrum,
            step=1,
            description='Last spectrum:',
            style=style)

        wind_first_channel = widgets.BoundedIntText(
            value=self.ind_first_channel,
            min=0,
            max=2048,
            step=1,
            description='First channel:',
            style=style)

        wind_last_channel = widgets.BoundedIntText(
            value=self.ind_last_channel,
            min=0,
            max=2048,
            step=1,
            description='Last channel:',
            style=style)

        wis_fluospectrum00 = widgets.Checkbox(
            value=self.is_elements[0],
            description='Element 0')

        wis_fluospectrum01 = widgets.Checkbox(
            value=self.is_elements[1],
            description='Element 1')

        wis_fluospectrum02 = widgets.Checkbox(
            value=self.is_elements[2],
            description='Element 2')

        wis_fluospectrum03 = widgets.Checkbox(
            value=self.is_elements[3],
            description='Element 3')

        wis_fluospectrum04 = widgets.Checkbox(
            value=self.is_elements[4],
            description='Element 4')

        wfilecheck = widgets.HBox([wfile,wis_load])
        wfluospectrum = widgets.HBox([wis_fluospectrum00, wis_fluospectrum01,wis_fluospectrum02,
                                      wis_fluospectrum03,wis_fluospectrum04])

        wind_channel = widgets.HBox([wind_first_channel, wind_last_channel])
        wind_spectrum = widgets.HBox([wind_first_spectrum, wind_last_spectrum])

        display(wfilecheck, wind_spectrum, wind_channel, wfluospectrum)

        button = widgets.Button(description="Click me to extract!")
        output = widgets.Output()

        display(button, output)

        def on_button_clicked(b):
            """Validate the values when the button is clicked."""

            # File should be local, in the same folder as the notebook.
            # Ex: file=SIRIUS_Fluo_2020_02_16_02289.nxs
            self.file = wfile.value

            # Ex: file_name=SIRIUS_Fluo_2020_02_16_02289
            self.file_name = self.file.split('\\')[-1][:-4]

            # Create a folder for saving params and results, if it does not already exist.
            if not os.path.exists(self.file_name):
                os.mkdir(self.file_name)

            self.is_fluospectrum00 = wis_fluospectrum00.value
            self.is_fluospectrum01 = wis_fluospectrum01.value
            self.is_fluospectrum02 = wis_fluospectrum02.value
            self.is_fluospectrum03 = wis_fluospectrum03.value
            self.is_fluospectrum04 = wis_fluospectrum04.value

            self.is_load = wis_load.value
            self.ind_first_spectrum = wind_first_spectrum.value
            self.ind_last_spectrum = wind_last_spectrum.value
            self.ind_first_channel = wind_first_channel.value
            self.ind_last_channel = wind_last_channel.value

            # Clear the plots and reput the boxes
            clear_output(wait=True)
            display(wfilecheck, wind_spectrum, wind_channel, wfluospectrum)
            display(button, output)

            if self.is_load:
                # (Re-)load the file
                self.extract_nexus()

                print("Extraction of %s."%self.file)
                print("There are %g spectrums in the scan."%(self.nb_allspectrums))

            # Define and plot the channels and spectrums subsets
            self.define_subsets()
            self.plot_subsets()

        button.on_click(on_button_clicked)


    def extract_nexus(self):
        """
        Extract all the requested fluospectrums in the nexus file.
        Correct with ICR/OCR.
        Sum the fluospectrums and put them in self.allspectrums_corr
        """
        self.nexus = PN.PyNexusFile(self.file, fast=True)

        # Number of spectrums taken during the scan
        self.nb_allspectrums = self.nexus.get_nbpts()

        stamps, data= self.nexus.extractData()

        fluospectrums_available = []
        for i in range(len(stamps)):
            if (stamps[i][1] != None and "fluospectrum0" in stamps[i][1].lower()):
                fluospectrums_available.append(stamps[i][1].lower()[-1])

        print("List of available elements: ", ["Element %s"%s for s in fluospectrums_available])

        fluospectrums_chosen = np.array([self.is_fluospectrum00,self.is_fluospectrum01,
                                         self.is_fluospectrum02,self.is_fluospectrum03, self.is_fluospectrum04])
        tmp = np.array([0,1,2,3,4])
        print("List of chosen elements: ", ["Element %g"%g for g in tmp[fluospectrums_chosen]])


        def extract_and_correct(ind_spectrum):
            """Extract the requested fluospectrum from the nexus file and correct it with ICR/OCR"""
            for i in range(len(stamps)):
                if (stamps[i][1] != None and stamps[i][1].lower() == "fluoicr0"+ind_spectrum):
                    fluoicr = data[i]
                if (stamps[i][1] != None and stamps[i][1].lower() == "fluoocr0"+ind_spectrum):
                    fluoocr = data[i]
                if (stamps[i][1] != None and stamps[i][1].lower() == "fluospectrum0"+ind_spectrum):
                    fluospectrum = data[i]
            ICR = fluoicr
            OCR = fluoocr
            ratio = np.array([ICR[n]/OCR[n] if (~np.isclose(OCR[n],0.) & ~np.isnan(OCR[n]) & ~np.isnan(ICR[n])) else 0. for n in range(len(ICR))])
            spectrums_corr = np.array([fluospectrum[n]*ratio[n] for n in range(len(ratio))])

            return spectrums_corr

        # Correct each chosen fluospectrum with ICR/OCR and sum them
        allspectrums_corr = np.zeros((self.nb_allspectrums, 2048))

        if self.is_fluospectrum00:
            fluospectrum00 = extract_and_correct('0')
            allspectrums_corr  = allspectrums_corr  + fluospectrum00
        if self.is_fluospectrum01:
            fluospectrum01 = extract_and_correct('1')
            allspectrums_corr  = allspectrums_corr  + fluospectrum01
        if self.is_fluospectrum02:
            fluospectrum02 = extract_and_correct('2')
            allspectrums_corr  = allspectrums_corr  + fluospectrum02
        if self.is_fluospectrum03:
            fluospectrum03 = extract_and_correct('3')
            allspectrums_corr  = allspectrums_corr  + fluospectrum03
        if self.is_fluospectrum04:
            fluospectrum04 = extract_and_correct('4')
            allspectrums_corr  = allspectrums_corr  + fluospectrum04

        self.allspectrums_corr = allspectrums_corr
        self.nexus.close()

    def define_subsets(self):
        """
        Select spectrums and channel range for the fits.
        """

        # Look for subsets of consecutive non-empty spectrums
        ind_non_zero_spectrums = np.where(np.sum(self.allspectrums_corr, axis = 1)>10.)[0]
        list_ranges = np.split(ind_non_zero_spectrums, np.where(np.diff(ind_non_zero_spectrums) != 1)[0]+1)
        self.last_non_zero_spectrum = ind_non_zero_spectrums[-1]

        #for ranges in list_ranges:
            #print('Recommended spectrum range: [%g:%g]'%(ranges[0],ranges[-1]))
        print('File empty after spectrum %g.'%ind_non_zero_spectrums[-1])

        # Subset of channels and spectrums defined by user
        self.channels = np.arange(self.ind_first_channel, self.ind_last_channel)
        self.spectrums = self.allspectrums_corr[self.ind_first_spectrum:self.ind_last_spectrum,
                                                self.ind_first_channel:self.ind_last_channel]

    def plot_subsets(self):
        # Plot the whole spectrum range (stopping at the last non-zero spectrum).
        # To check which subset the user wants.
        fig = plt.figure(figsize=(12,6))
        fig.suptitle(self.file, fontsize=14)
        ax1 = fig.add_subplot(111)
        ax1.set_title('All the spectrums in the file (stopping at the last non-zero spectrum)')
        ax1.set(xlabel = 'spectrum index', ylabel = 'channel')
        ax1.set_xlim(left = -1, right = self.last_non_zero_spectrum+1)
        ax1.axvline(self.ind_first_spectrum, linestyle = '--', color = 'y', label = 'Selected spectrum range')
        ax1.axvline(self.ind_last_spectrum, linestyle = '--', color = 'y')
        im1 = ax1.imshow(self.allspectrums_corr.transpose(), cmap = 'viridis', aspect = 'auto', norm=mplcolors.LogNorm())
        plt.legend()

        # Plot the whole channel range
        fig = plt.figure(figsize=(12,8))
        ax1 = fig.add_subplot(211)
        ax1.set_title('Whole range of channels on the sum of all spectrums')
        ax1.set(xlabel = 'channel', ylabel = 'counts')
        ax1.axvline(self.ind_first_channel, linestyle = '--', color = 'r', label = 'Selected channel range')
        ax1.axvline(self.ind_last_channel, linestyle = '--', color = 'r')
        ax1.plot(np.arange(2048), self.allspectrums_corr.sum(axis = 0), 'k.-')
        ax1.legend()
        plt.setp(ax1.get_xticklabels(), visible=False)

        ax2 = fig.add_subplot(212)
        ax2.set(xlabel = 'channel', ylabel = 'counts')
        ax2.axvline(self.ind_first_channel, linestyle = '--', color = 'r')
        ax2.axvline(self.ind_last_channel, linestyle = '--', color = 'r')
        ax2.plot(np.arange(2048), self.allspectrums_corr.sum(axis = 0), 'k.-')
        ax2.set_yscale('log')
        ax2.set_ylim(bottom = 1)
        yticks = ax1.yaxis.get_major_ticks()
        yticks[-1].label1.set_visible(False)
        plt.subplots_adjust(hspace=.0)

        #Plot the selected spectrum range
        fig = plt.figure(figsize=(12,6))
        fig.suptitle('SELECTED RANGES', fontsize=14)
        ax1 = fig.add_subplot(111)
        ax1.set_title('Subset of spectrums [%g:%g]'%(self.ind_first_spectrum,self.ind_last_spectrum))
        ax1.set(xlabel = 'spectrum index', ylabel = 'channel')
        im1 = ax1.imshow(self.spectrums.transpose(), cmap = 'viridis', aspect = 'auto', norm=mplcolors.LogNorm(),
                         interpolation='none',
                         extent=[self.ind_first_spectrum,self.ind_last_spectrum,
                                 self.ind_last_channel,self.ind_first_channel])

        #Plot the selected channel range
        fig = plt.figure(figsize=(12,8))
        ax1 = fig.add_subplot(211)
        ax1.set_title('Subset of channels [%g:%g]'%(self.ind_first_channel,self.ind_last_channel))
        ax1.set(xlabel = 'channel', ylabel = 'counts')
        ax1.plot(self.channels, self.spectrums[0], 'r-', label = 'Spectrum %g'%self.ind_first_spectrum)
        ax1.plot(self.channels, self.spectrums[-1], 'b-', label = 'Spectrum %g'%self.ind_last_spectrum)
        ax1.legend()
        plt.setp(ax1.get_xticklabels(), visible=False)

        ax2 = fig.add_subplot(212)
        ax2.set(xlabel = 'channel', ylabel = 'counts')
        ax2.plot(self.channels, self.spectrums[0], 'r-')
        ax2.plot(self.channels, self.spectrums[-1], 'b-')
        ax2.set_yscale('log')
        ax2.set_ylim(bottom = 1)
        yticks = ax1.yaxis.get_major_ticks()
        yticks[-1].label1.set_visible(False)
        plt.subplots_adjust(hspace=.0)

        if np.sum(self.spectrums[0])<10.:
            CBOLD = '\033[1m'
            CEND = '\033[0m'
            print(CBOLD + 'ERROR: The first spectrum cannot be empty!!!' + CEND)


    def define_peaks(self):
        """
        1) Check if the csv file Peaks.csv exists, if not create it with an example.
        2) If ipysheet is activated, display the interactive sheet. If not, extract the peaks from Peaks.csv
        3) Save the peaks in Peaks.csv
        Update self.arr_peaks, with the info on the peaks later used to create the Elem and Lines objects.
        """

        nb_rows = 20

        # Array which will contain the info on peaks
        arr_peaks = np.array([])

        # Check if the csv file already exists, if not copy the DefaultPeaks.csv file
        if not os.path.isfile(self.file_name+'/Peaks.csv'):
            shutil.copy('DefaultPeaks.csv', self.file_name+'/Peaks.csv')

        with open(self.file_name+'/Peaks.csv', "r") as f:
            csvreader = csv.reader(f, delimiter=self.delimiter)
            # First line is the header
            self.peaks_header = next(csvreader)
            nb_columns = len(self.peaks_header)
            for row in csvreader:
                arr_peaks = np.append(arr_peaks, row)
        arr_peaks = np.reshape(arr_peaks, (len(arr_peaks)//nb_columns,nb_columns))


        if self.is_ipysheet:
            sheet = ipysheet.easy.sheet(columns=nb_columns, rows=nb_rows ,column_headers = self.peaks_header)

            # ipysheet does not work correctly with None entries
            # It is necessary to fill first the cells with something
            nb_rows_to_fill = nb_rows - np.shape(arr_peaks)[0]
            fill = np.reshape(np.array(nb_rows_to_fill*nb_columns*['']),
                              (nb_rows_to_fill, nb_columns))
            arr_peaks = np.vstack((arr_peaks, fill))

            for i in range(nb_columns):
                ipysheet.easy.column(i,  arr_peaks[:,i])
            display(sheet)

        else:
            print("Peaks imported from %s"%(self.file_name+'/Peaks.csv'))
            print('\t'.join([str(cell) for cell in self.peaks_header]))
            print('\n'.join(['\t \t'.join([str(cell) for cell in row]) for row in arr_peaks if row[0]!='']))


        self.arr_peaks = arr_peaks

    def extract_elems(self):
        """
        1) Validate the current sheet if using ipysheet
        2) Create objects Elem and Lines from info in self.arr_peaks
        """
        # 1) Validate the current sheet if using ipysheet
        if self.is_ipysheet:
            self.validate_sheet()

        # 2) Create objects Elem and Lines from info in arr_peaks
        # Each "Peak name" gives a new Elem with Elem.name = "Peak name"
        # Each "Line name" gives a new Elem.Line with Elem.Line.name = "Line name"
        # "Position (eV)" -> Elem.Line.position_i
        # "Fit position?" -> Elem.Line.is_fitpos
        # The array self.elems contains the list of objects Elem

        # Remove the peaks which are not fitted from self.arr_peaks
        self.arr_peaks = self.arr_peaks[np.where(self.arr_peaks[:,4]!='no')]

        elems = []
        for i in range(np.shape(self.arr_peaks)[0]):
            elem_name = self.arr_peaks[i][0]
            if (elem_name != '' and elem_name != self.arr_peaks[i-1][0]):
                newElem = Elem(elem_name)
                elems = np.append(elems, newElem)
                elems[-1].lines = []

        for i in range(np.shape(self.arr_peaks)[0]):
            elem_name = self.arr_peaks[i][0]
            for elem in elems:
                if elem.name == elem_name:
                    if self.arr_peaks[i][3] == 'yes':
                        is_fitpos = True
                    else:
                        is_fitpos = False
                    elem.newLine = Line(name = str(self.arr_peaks[i][1]),
                                        position_i = float(self.arr_peaks[i][2]),
                                        is_fitpos = is_fitpos)
                    elem.lines = np.append(elem.lines, elem.newLine)

        self.elems = elems


    def validate_sheet(self):
        """
        Validate the info in the current sheet by transferring them to self.arr_peaks and save them in Peaks.csv
        """

        # Collect the info from the sheet, store them in arr_peaks, write to Peaks.csv
        arr_peaks = ipysheet.numpy_loader.to_array(ipysheet.easy.current())

        with open(self.file_name+'/Peaks.csv', "w", newline='') as f:
            writer = csv.writer(f,delimiter=self.delimiter)
            writer.writerow(self.peaks_header)
            writer.writerows(arr_peaks)

        # String to print the peaks
        prt_peaks = '\t'.join([str(cell) for cell in self.peaks_header])+'\n'
        prt_peaks += '\n'.join(['\t \t'.join([str(cell) for cell in row]) for row in arr_peaks if row[0]!=''])+'\n'
        prt_peaks += "Peaks saved in %s"%(self.file_name+'/Peaks.csv')

        self.arr_peaks = arr_peaks
        self.prt_peaks = prt_peaks


    def display_peaks(self,spectrum_index):
        """
        1) Define initial guesses for the relative amplitudes of each lines from each elem, used later in the fit.
        2) Plot the position of each peaks on the given spectrum spectrum_index.
        Takes spectrum_index, the index of which spectrum you want to use.
        """

        # Convert channels into eV
        self.eV = self.channels*self.gain + self.eV0

        eV = self.eV
        elems = self.elems

        # We work on the spectrum specified by spectrum_index
        spectrum = self.spectrums[spectrum_index]

        # 1) Define initial guesses for the relative amplitudes
        # Get each peak approx. intensity (intensity at the given peak position)
        for elem in elems:
            for line in elem.lines:
                    position = line.position_i
                    ind_position = np.argmin(np.abs(np.array(eV)-position))
                    intensity = spectrum[ind_position]
                    line.intensity_0 = float(intensity)

        # If the relative intensity of each line is not known a priori and therefore fitted:
        # An initial guess is extracted from the intensity of the spectrum at the given line position
        for elem in elems:
            # Get the intensity of the most intense line
            temp_list = []
            for line in elem.lines:
                temp_list.append(line.intensity_0)
            highest = np.max(temp_list)

            # Normalise all the lines relative to the most intense one
            if elem.isfit_intRel:
                for line in elem.lines:
                    line.intRel_i = line.intensity_0/highest


        # 2) Plot the spectrum and each line given by the user
        self.plot_spectrum(spectrum_index=spectrum_index)

        if self.is_ipysheet: print(self.prt_peaks)


    def plot_spectrum(self, spectrum_index, dparams_list=None, is_save = False):
        """
        Plot data of a specific spectrum (given by spectrum_index).
        If a dparams_list is given, redo and plot the fit with the given parameters.
        If is_save, save the plots in png and the fitting curve in spectrum_X_fit.csv
        """
        n = spectrum_index
        eV = self.eV
        elems = self.elems

        spectrum = self.spectrums[n]

        if dparams_list != None:
            sl_list = dparams_list['sl_list']
            ct_list = dparams_list['ct_list']

            # Fit the spectrum with the given parameters
            for elem in elems:
                elem.area = elem.area_list[n]
                for line in elem.lines:
                    line.position = line.position_list[n]
                    line.intRel = line.intRel_list[n]
            dparams = {}
            for name in dparams_list:
                dparams[name[:-5]] = dparams_list[name][n]
            spectrum_fit = fcn_spectrum(dparams, elems, eV)

        else:
            for elem in elems:
                for line in elem.lines:
                    line.position = line.position_i

        # Plot the whole spectrum
        fig = plt.figure(figsize=(15,10))
        ax1 = fig.add_subplot(211)
        colors = iter(['r', 'b', 'y', 'c', 'm', 'g', 'orange', 'brown']*20)
        ax1.set(xlabel = 'E (eV)', ylabel = 'counts')
        for elem in elems:
            for line in elem.lines:
                position = line.position
                ax1.axvline(x = position,  color = next(colors), linestyle = '--', label = elem.name+' '+line.name)
        ax1.plot(eV, spectrum, 'k.')
        if dparams_list != None: ax1.plot(eV, spectrum_fit, 'r-')
        ax1.legend()
        plt.setp(ax1.get_xticklabels(), visible=False)


        ax2 = fig.add_subplot(212)
        colors = iter(['r', 'b', 'y', 'c', 'm', 'g', 'orange', 'brown']*20)
        ax2.set(xlabel = 'E (eV)', ylabel = 'counts')
        for elem in elems:
            for line in elem.lines:
                position = line.position
                ax2.axvline(x = position,  color = next(colors), linestyle = '--')
        ax2.plot(eV, spectrum, 'k.')
        if dparams_list != None:
            ax2.plot(eV, spectrum_fit, 'r-')
            #ax2.plot(eV, sl_list[n]*eV+ct_list[n], 'b-', label = 'Linear background')
            #ax2.legend(loc = 1)
        ax2.set_ylim(bottom = 1)
        ax2.set_yscale('log')
        yticks = ax1.yaxis.get_major_ticks()
        yticks[-1].label1.set_visible(False)
        plt.subplots_adjust(hspace=.0)
        fig.subplots_adjust(top=0.93)
        fig.suptitle(self.file+'\n'+'Spectrum number %g/%g'%(n,(len(self.spectrums)-1)), fontsize=14)

        if is_save:
            delimiter = self.delimiter
            plt.savefig(self.file_name+'/spectrum_'+str(spectrum_index)+'_fit.png')
            np.savetxt(str(self.file_name+'/spectrum_'+str(spectrum_index)+'_fit.csv'),
                       np.transpose([eV, spectrum, spectrum_fit]),
                       header = '#eV'+delimiter+'#spectrum'+delimiter+'#spectrum_fit',
                       delimiter = delimiter,
                       comments = ''
                      )
        plt.show()
        plt.close()

        # Plot each peak
        colors = iter(['r', 'b', 'y', 'c', 'm', 'g', 'orange', 'brown']*20)

        for elem in elems:
            print('##########################################################################################')
            # Divide the grid in nblines x 2
            nblines = len(elem.lines)
            grid = plt.GridSpec((nblines+1)//2, 2, wspace=0.1, hspace=0.4)

            if nblines > 1:
                fig = plt.figure(figsize=(15,(5+0.8)*nblines//2))
            else :
                fig = plt.figure(figsize=(15,5))

            count = 0
            for line in elem.lines:
                    plt.subplot(grid[count//2, count%2])

                    position = line.position
                    position_i = line.position_i

                    ind_min = np.argmin(np.abs(np.array(eV)-0.9*position))
                    ind_max = np.argmin(np.abs(np.array(eV)-1.1*position))

                    spectrum_zoom = spectrum[ind_min:ind_max]
                    eV_zoom = eV[ind_min:ind_max]

                    if dparams_list != None:
                        spectrum_fit_zoom = spectrum_fit[ind_min:ind_max]
                        intRel = line.intRel_list[n]
                        area = elem.area_list[n]

                        if line.is_fitpos:
                            title0 = 'position(init) = %g eV, position(fit)=%g eV'%(position_i,position)
                        else:
                            title0 = 'position = %g eV'%(position)

                        title = elem.name + ' ' + line.name + '\n' \
                                +'elem area = %g, relative int = %g'%(area,intRel) + '\n'\
                                + title0
                    else:
                        title = elem.name + ' ' + line.name +'\n'+'position = %g eV'%(position)

                    plt.gca().set_title(title)

                    plt.plot(eV_zoom, spectrum_zoom, 'k.')
                    if dparams_list != None: plt.plot(eV_zoom, spectrum_fit_zoom, 'r-')
                    plt.xlabel('E (eV)')

                    # Plot each line in the zoom
                    for elem_tmp in elems:
                        for line_tmp in elem_tmp.lines:
                            position_tmp = line_tmp.position
                            if (eV[ind_min]<position_tmp and eV[ind_max]>position_tmp):
                                plt.axvline(x = position_tmp , label = elem_tmp.name+' '+line_tmp.name, linestyle = '--', color = next(colors))
                    plt.legend()

                    count +=1
            plt.show()


    def fit_spectrums(self, is_save=True):
        """
        Fit procedure. Will fit each spectrum in spectrums.
        Results are saved in FitResults.csv and in dparams_list, a dictionary with a list entry per param.
        """

        #####################################################
        ################   PREPARE FIT   ####################
        #####################################################

        eV = self.eV
        elems = self.elems
        dparams_fit = self.dparams_fit

        # Dictionnary with a list for each parameter updated at each fit
        dparams_list = {'sl_list','ct_list',
                        'sfa0_list','sfa1_list','tfb0_list','tfb1_list',
                        'twc0_list','twc1_list',
                        'noise_list','fan_list', 'epsilon_list',
                        'fG_list','fA_list','fB_list','gammaA_list','gammaB_list'}

        # Init all the lists
        dparams_list = dict.fromkeys(dparams_list, np.array([]))

        for elem in elems:
            elem.area_list = np.array([])
            for line in elem.lines:
                line.intRel_tmp = np.array([])
                line.intRel_list = np.array([])
                line.position_list = np.array([])

        #####################################################
        ##############   PREPARE SAVE   #####################
        #####################################################
        if is_save:
            # Prepare the header of the csv file
            with open(self.file_name+'/FitResults.csv', "w", newline='') as f:
                writer = csv.writer(f,delimiter=self.delimiter)
                header = np.array([])
                for elem in elems:
                    header = np.append(header, '#'+elem.name+'.area')
                    for line in elem.lines:
                        header = np.append(header,'#'+elem.name+'.'+line.name+'.intRel')
                        header = np.append(header,'#'+elem.name+'.'+line.name+'.position')

                for name in dparams_list:
                    header = np.append(header, '#'+name[:-5])

                writer.writerow(header)


        count=0
        for spectrum in self.spectrums:

            #####################################################
            #####################   FIT   #######################
            #####################################################

            # Allow or not transmission of current fit params as init params for the next fit 
            is_transmitted = False
            if is_transmitted:
                # Initial guess for peak params
                if count==0:
                    # First loop : initial guess is given by the expert fit parameters
                    dparams_0 = dparams_fit.copy()
                else:
                    # For the next loops, initial guess is given by the results of the previous fit
                    dparams_0 = {}
                    for name in dparams_list:
                        dparams_0[name[:-5]] = dparams_list[name][-1]
            else:
                # Initial guess is always given by the expert fit parameters
                dparams_0 = dparams_fit.copy()
                    
            # Least squares fit
            # Find the least squares solution to the equation ax=b, used as initial guess for the LM fit.
            # p contains the best fit for the area of each elem (elem.area)
            # Results with the subscript ls
            a = []
            for elem in elems:
                spectrum_elem = 0.
                for line in elem.lines:
                        position = line.position_i
                        intRel = line.intRel_i
                        if elem.name == 'Compton':
                            spectrum_elem += fcn_compton_peak(position,intRel,eV,dparams_0)
                        else:
                            spectrum_elem += fcn_peak(position,intRel,eV,dparams_0)
                a.append(spectrum_elem)
            a = np.transpose(a)
            b = spectrum

            area_ls, residues, rank, sv = linalg.lstsq(a,b,1.e-10)

            # Store the elem.area of each elem
            i=0
            for elem in elems:
                elem.area_ls = area_ls[i]
                i+=1

            ###################################
            # LMFIT
            dparams_lm = Parameters()

            for elem in elems:
                dparams_lm.add('area_'+elem.name, value=elem.area_ls, vary=True, min = 0.)
                for line in elem.lines:
                    # Decides whether the relative intensity of the line should be fitted
                    if isclose(line.intRel_i,1.):
                        # Keeps the most intense peak at a relative intensity of 1 (by definition)
                        dparams_lm.add('intRel_'+elem.name+'_'+line.name, value=1., vary=False)
                    else:
                        # The first curves are used to set the relative intensities
                        if count < 5:
                            dparams_lm.add('intRel_'+elem.name+'_'+line.name, value=line.intRel_i, vary=elem.isfit_intRel, min = 0., max = 1.)
                        else:
                            dparams_lm.add('intRel_'+elem.name+'_'+line.name, value=line.intRel, vary=False)

                    # Check whether the position of the line should be fitted
                    if line.is_fitpos:
                        dparams_lm.add('pos_'+elem.name+'_'+line.name, value=line.position_i, vary = True,
                                   min = line.position_i-100, max = line.position_i+100)
                    else:
                        dparams_lm.add('pos_'+elem.name+'_'+line.name, value=line.position_i, vary = False)


            dparams_lm.add('sl', value=dparams_0['sl'])
            dparams_lm.add('ct', value=dparams_0['ct'])
            dparams_lm.add('sfa0', value=dparams_0['sfa0'])
            dparams_lm.add('sfa1', value=dparams_0['sfa1'], min = 0.)
            dparams_lm.add('tfb0', value=dparams_0['tfb0'])
            dparams_lm.add('tfb1', value=dparams_0['tfb1'], min = 0.)
            dparams_lm.add('twc0', value=dparams_0['twc0'])
            dparams_lm.add('twc1', value=dparams_0['twc1'], min = 0.)
            dparams_lm.add('noise', value=dparams_0['noise'])
            dparams_lm.add('fan', value=dparams_0['fan'])
            dparams_lm.add('epsilon', value=dparams_0['epsilon'])
            dparams_lm.add('fG', value=dparams_0['fG'], min = 0.)
            dparams_lm.add('fA', value=dparams_0['fA'], min = 0.)
            dparams_lm.add('fB', value=dparams_0['fB'], min = 0.)
            dparams_lm.add('gammaA', value=dparams_0['gammaA'], min = 0.)
            dparams_lm.add('gammaB', value=dparams_0['gammaB'], min = 0.)

            # Check in list_isfit which peak params should be fitted
            # By default vary = True in dparams_lm.add
            for name in dparams_fit:
                dparams_lm[name].vary = False
                dparams_lm[name].vary = name in self.list_isfit

            self.is_fitstuck = False   
            def iter_cb(params, nb_iter, resid, *args, **kws):
                
                # Stop the current fit if it is stuck or if the spectrum is empty
                if nb_iter > self.fitstuck_limit:
                    self.is_fitstuck = True
                
                if np.sum(spectrum)<10.:
                    self.is_fitstuck = True
                    
                return self.is_fitstuck
   
            # Do the fit, here with leastsq model
            minner = Minimizer(fcn2min, dparams_lm, fcn_args=(elems, eV, spectrum), iter_cb=iter_cb, xtol = 1e-6, ftol = 1e-6)

            result = minner.minimize(method = 'leastsq')

            # Calculate final result with the residuals
            #final = spectrum + result.residual

            # Extract the results of the fit and put them in lists
            
            if self.is_fitstuck:
                
                # If the fit was stuck we put the value set by fitstuck_value everywhere
                for elem in elems:
                    elem.area_list = np.append(elem.area_list, self.fitstuck_value)

                    for line in elem.lines:
                        line.intRel_list = np.append(line.intRel_list , self.fitstuck_value)
                        line.position_list = np.append(line.position_list, self.fitstuck_value)

                for name in dparams_list:
                    dparams_list[name] =  np.append(dparams_list[name], self.fitstuck_value)

            else:
                for elem in elems:
                    elem.area_list = np.append(elem.area_list, result.params['area_'+elem.name].value)

                    for line in elem.lines:
                        if count<5:
                            # The first fits are used to set the relative intensities
                            line.intRel_tmp = np.append(line.intRel_tmp, result.params['intRel_'+elem.name+'_'+line.name].value)
                            line.intRel = np.mean(line.intRel_tmp)

                        line.intRel_list = np.append(line.intRel_list , result.params['intRel_'+elem.name+'_'+line.name].value)
                        line.position_list = np.append(line.position_list, result.params['pos_'+elem.name+'_'+line.name].value)

                for name in dparams_list:
                    dparams_list[name] =  np.append(dparams_list[name], result.params[name[:-5]].value)

            #####################################################
            #####################   SAVE   ######################
            #####################################################
            if is_save:
                with open(self.file_name+'/FitResults.csv', 'a+', newline='') as f:
                    writer = csv.writer(f,delimiter=self.delimiter)
                    tbw = np.array([], dtype='float')
                    for elem in elems:
                        tbw = np.append(tbw,elem.area_list[-1])
                        for line in elem.lines:
                            tbw = np.append(tbw,line.intRel_list[-1])
                            tbw = np.append(tbw,line.position_list[-1])
                    for name in dparams_list:
                        tbw = np.append(tbw,dparams_list[name][-1])
                    writer.writerow(tbw)

            #####################################################
            ###############   PLOT CURRENT FIT  #################
            #####################################################

            # Plot the spectrum and the fit, updated continuously

            # Dictionnary with the results of the last fit iteration
            dparams = {}
            for name in dparams_list:
                dparams[name[:-5]] = dparams_list[name][-1]
            spectrum_fit = fcn_spectrum(dparams, elems, eV)

            clear_output(wait=True) # This line sets the refreshing
            fig = plt.figure(figsize=(15,10))
            fig.suptitle('Fit of spectrum %g/%g'%(count,(len(self.spectrums)-1)), fontsize=14)
            fig.subplots_adjust(top=0.95)
            ax1 = fig.add_subplot(211)
            colors = iter(['r', 'b', 'y', 'c', 'm', 'g', 'orange', 'brown']*20)
            ax1.set(xlabel = 'E (eV)', ylabel = 'counts')
            for elem in elems:
                for line in elem.lines:
                    position = line.position_list[-1]
                    ax1.axvline(x = position,  color = next(colors) , label = elem.name+' '+line.name)
            ax1.plot(eV, spectrum, 'k.')
            ax1.plot(eV, spectrum_fit, 'r-')
            ax1.legend()
            plt.setp(ax1.get_xticklabels(), visible=False)

            ax2 = fig.add_subplot(212)
            colors = iter(['r', 'b', 'y', 'c', 'm', 'g', 'orange', 'brown']*20)
            ax2.set(xlabel = 'E (eV)', ylabel = 'counts')
            for elem in elems:
                for line in elem.lines:
                    position = line.position_list[-1]
                    ax2.axvline(x = position,  color = next(colors))
            ax2.plot(eV, spectrum, 'k.')
            ax2.plot(eV, spectrum_fit, 'r-')
            #ax2.plot(eV, dparams['sl']*eV+dparams['ct'], 'b-', label = 'Linear background')
            #ax2.legend(loc = 1)
            ax2.set_ylim(1,1e6)
            ax2.set_yscale('log')
            yticks = ax1.yaxis.get_major_ticks()
            yticks[-1].label1.set_visible(False)
            plt.subplots_adjust(hspace=.0)
            plt.show()

            count+=1

        #####################################################
        ##################   PLOT PARAMS  ###################
        #####################################################

        # At the end of the fit, plot the evolution of each param as a function of the scan
        print('####################################################')
        print('Fits are done. Results shown below.')
        print('####################################################')
        print('')

        # Results after fits
        self.dparams_list = dparams_list

        self.plot_params(spectrum_index=None, dparams_list=dparams_list, is_save=is_save)

        print('#####################################################')
        print('Results are saved in: %s'%(self.file_name+'/FitResults.csv'))


    def plot_params(self, spectrum_index=None, dparams_list=None, is_save=False):
        """
        Plot all the params in dparams_list, as a function of the spectrum.
        If spectrum_index is given, plot its position on each plot.
        If is_save, save each plot in a png.
        """
        elems = self.elems
        file_name = self.file_name
        spectrums = self.spectrums

        scans = np.arange(np.shape(spectrums)[0])
        print('###################### AREAS ########################')
        for elem in elems:
            fig, ax = plt.subplots(figsize=(15,4))
            ax.yaxis.set_major_formatter(FormatStrFormatter('%g'))
            plt.plot(scans, elem.area_list, 'r.-', label = 'Area %s'%elem.name)
            if spectrum_index!=None: plt.axvline(x = spectrum_index, linestyle = '--', color = 'black')
            plt.legend()
            if is_save: plt.savefig(file_name+'/area_'+elem.name+'.png')
            plt.show()

        isprintbanner = True
        for elem in elems:
            for line in elem.lines:
                if line.is_fitpos:
                    if isprintbanner:
                        print('###################### POSITIONS ########################')
                        isprintbanner = False
                    fig, ax = plt.subplots(figsize=(15,4))
                    ax.yaxis.set_major_formatter(FormatStrFormatter('%g'))
                    plt.plot(scans, line.position_list, 'b.-', label = 'Position %s '%(elem.name+'.'+line.name))
                    plt.legend()
                    if is_save: plt.savefig(file_name+'/position_'+elem.name+line.name+'.png')
                    if spectrum_index!=None: plt.axvline(x = spectrum_index, linestyle = '--', color = 'black')
                    plt.show()

        print('################### OTHER PARAMETERS ######################')
        # Plot only the params which vary
        for name in dparams_list:
            if np.any(dparams_list[name]!=dparams_list[name][0]):
                fig, ax = plt.subplots(figsize=(15,4))
                ax.yaxis.set_major_formatter(FormatStrFormatter('%g'))
                plt.plot(scans, dparams_list[name], 'k.-', label = name[:-5])
                plt.legend()
                if is_save: plt.savefig(file_name+'/'+str(name[:-5])+'.png')
                if spectrum_index!=None: plt.axvline(x = spectrum_index, linestyle = '--', color = 'black')
                plt.show()

    def load_results(self, spectrum_index, is_save=False):
        """
        Load and plot the results of a previous fit
        If is_save, save the fitting curve as a csv and as a png
        Read the result from FitResults.csv
        """
        elems = self.elems
        file_name = self.file_name

        if is_save:
            print('Saved: spectrum_'+str(spectrum_index)+'_fig.csv')
            print('Saved: spectrum_'+str(spectrum_index)+'_fit.png')

        dparams_list = {'sl_list','ct_list',
                        'sfa0_list','sfa1_list','tfb0_list','tfb1_list',
                        'twc0_list','twc1_list',
                        'noise_list','fan_list', 'epsilon_list',
                        'fG_list','fA_list','fB_list','gammaA_list','gammaB_list'}

        # Init all the lists
        dparams_list = dict.fromkeys(dparams_list, np.array([]))

        for elem in elems:
            elem.area_list = np.array([])
            for line in elem.lines:
                line.intRel_list = np.array([])
                line.position_list = np.array([])


        with open(file_name+'/FitResults.csv', "r") as f:
            reader = csv.DictReader(f, delimiter=self.delimiter)
            for row in reader:
                for elem in elems:
                    elem.area_list = np.append(elem.area_list, np.float(row['#'+elem.name+'.area'].replace(',','.')))

                    for line in elem.lines:
                        line.intRel_list = np.append(line.intRel_list, np.float(row['#'+elem.name+'.'+line.name+'.intRel'].replace(',','.')))
                        line.position_list = np.append(line.position_list, np.float(row['#'+elem.name+'.'+line.name+'.position'].replace(',','.')))

                for name in dparams_list:
                        dparams_list[name] = np.append(dparams_list[name], np.float(row['#'+name[:-5]].replace(',','.')))

         
        self.plot_spectrum(spectrum_index, dparams_list,  is_save)
        self.plot_params(spectrum_index, dparams_list, is_save)

class Elem:
    def __init__(self, name, isfit_intRel = True):
        self.name = name
        self.lines = []

        # Set if the relative intensity is fitted
        self.isfit_intRel = isfit_intRel

class Line:
    def __init__(self, name, position_i, intRel_i = 1., is_fitpos = False):
        self.name = name

        # Position before any fit
        self.position_i = position_i

        # Set if the position of the line is fitted
        self.is_fitpos = is_fitpos

        # The relative intensity (relative to the most intense one,
        # i.e. intRel = 1 for the most intense line of an elem)
        # If isfit_intRel = True, it will be fitted, else it should be given
        self.intRel_i = intRel_i




########################## FUNCTIONS FOR SPECTRUM DEFINITION ######################################

def fcn2min(dparams, elems, eV, data):
    """
    Define objective function: returns the array to be minimized in the lmfit.
    """
    for elem in elems:
        elem.area = dparams['area_'+elem.name]

        for line in elem.lines:
            line.intRel = float(dparams['intRel_'+elem.name+'_'+line.name])
            line.position = float(dparams['pos_'+elem.name+'_'+line.name])

    model = fcn_spectrum(dparams, elems, eV)

    return model - data


def fcn_spectrum(dparams, elems, eV):
    """
    Definition of the spectrum as the sum of the peaks + the background.
    Takes a dictionnary with the params values, the list of Elem, the array of eV.
    """

    ct = dparams['ct']
    sl = dparams['sl']
    noise = dparams['noise']

    spectrum_tot = 0.
    for elem in elems:
        spectrum_elem = 0.
        area = elem.area
        for line in elem.lines:
            position = line.position
            intRel = line.intRel
            if elem.name == 'Compton':
                spectrum_elem += area*fcn_compton_peak(position,intRel,eV,dparams)
            else:
                spectrum_elem += area*fcn_peak(position,intRel,eV,dparams)
        spectrum_tot += spectrum_elem

    # We add a linear baseline, which cannot be < 0, and stops after the elastic peak (if there is one)
    limit_baseline = eV[-1]
    for elem in elems:
        if elem.name == 'Elastic':
            for line in elem.lines:
                if line.name == 'El':
                    limit_baseline = line.position

    eV_tmp = np.where(eV<limit_baseline+noise, eV, 0.)
    baseline = ct+sl*eV_tmp
    baseline = np.where(baseline>0.,baseline,0.)
    spectrum_tot+= baseline

    return spectrum_tot

def scf(atom, energy):
    """
    Interpolation for the scattering factors.
    Used here to take into account absorption from Si within the detector.
    Requires the file f-si in the same folder as the notebook.
    """
    en2=0.
    f2=0.
    f2p=0.
    for line in open('f-'+str(atom),'r'):
        en1=en2
        f1=f2
        f1p=f2p
        try:
            en2=float(line.split()[0])
            f2=float(line.split()[1])
            f2p=float(line.split()[2])
            if en1<=energy and en2>energy:
                scf=f1+(energy-en1)/(en2-en1)*(f2-f1)
                scfp=f1p+(energy-en1)/(en2-en1)*(f2p-f1p)
            else:
                pass
        except:
            pass
    return scf,scfp

def fcn_peak(pos, amp, eV, dparams):
    """
    Definition of a peak (area normalised to 1).
    Following:
    - M. Van Gysel, P. Lemberge & P. Van Espen, “Implementation of a spectrum fitting
    procedure using a robust peak model”, X-Ray Spectrometry 32 (2003), 434–441
    - J. Campbell & J.-X. Wang, “Improved model for the intensity of low-energy tailing in
    Si (Li) x-ray spectra”, X-Ray Spectrometry 20 (1991), 191–197
    The params for peak definition should be passed as a dictionnary :
    dparams = {'sl': 0.01, 'ct':-23., 'sfa0':1.3 ... }
    """

    sfa0 = dparams['sfa0']
    sfa1 = dparams['sfa1']
    tfb0 = dparams['tfb0']
    tfb1 = dparams['tfb1']
    twc0 = dparams['twc0']
    twc1 = dparams['twc1']
    noise = dparams['noise']
    fan = dparams['fan']
    epsilon = dparams['epsilon']

    # We work in keV for the peak definition
    pos_keV = pos/1000.
    keV = eV/1000.

    # Peak width after correction from detector resolution (sigmajk)
    wid = np.sqrt((noise/2.3548)**2.+epsilon*fan*pos_keV)

    # Tail width (cannot be <0)
    TW = twc0 + twc1*pos_keV
    TW = np.where(TW>0.,TW,0.)

    # Energy dependent attenuation by Si in the detector
    atwe_Si = 28.086 #atomic weight in g/mol
    rad_el = 2.815e-15 #radius electron in m
    Na = 6.02e23 # in mol-1
    llambda = 12398./pos*1e-10 # in m
    # mass attenuation coefficient of Si in cm^2/g
    musi = 2.*llambda*rad_el*Na*1e4*float(scf('si',pos)[1])/atwe_Si

    # Shelf fraction SF (cannot be <0)
    SF = (sfa0 + sfa1*pos_keV)*musi
    SF = np.where(SF>0.,SF,0.)
    
    # Tail fraction TF (cannot be <0)
    TF = tfb0 + tfb1*musi
    TF = np.where(TF>0.,TF,0.)

    # Definition of gaussian
    arg = (keV-pos_keV)**2./(2.*wid**2.)
    farg = (keV-pos_keV)/wid
    gau = amp/(np.sqrt(2.*np.pi)*wid)*np.exp(-arg)

    # Function shelf S(i, Ejk)
    she = amp/(2.*pos_keV)*erfc(farg/np.sqrt(2.))

    # Function tail T(i, Ejk)
    tail = amp/(2.*wid*TW)*np.exp(farg/TW+1/(2*TW**2))*erfc(farg/np.sqrt(2.)+1./(np.sqrt(2.)*TW))

    # Function Peak
    ppic = np.array(gau+SF*she+TF*tail)

    return ppic

def fcn_compton_peak(pos, amp, eV, dparams):
    """
    The function used to fit the compton peak, inspired by  M. Van Gysel, P. Lemberge & P. Van Espen,
    “Description of Compton peaks in energy-dispersive  x-ray fluorescence spectra”,
    X-Ray Spectrometry 32 (2003), 139–147
    The params for peak definition should be passed as a dictionnary :
    dparams = {'fG': 0.01, 'fA':2., ... }
    """

    fG = dparams['fG']
    fA = dparams['fA']
    fB = dparams['fB']
    gammaA = dparams['gammaA']
    gammaB = dparams['gammaB']
    noise = dparams['noise']
    fan = dparams['fan']
    epsilon = dparams['epsilon']

    # We work in keV for the peak definition
    pos_keV = pos/1000.
    keV = eV/1000.

    # Peak width after correction from detector resolution (sigmajk)
    wid = np.sqrt((noise/2.3548)**2.+epsilon*fan*pos_keV)

    # Definition of gaussian
    arg = (keV-pos_keV)**2./(2.*(fG*wid)**2.)
    gau = amp/(np.sqrt(2.*np.pi)*fG*wid)*np.exp(-arg)

    #Low energy tail TA
    farg = (keV-pos_keV)/wid
    TA = amp/(2.*wid*gammaA)*np.exp(farg/gammaA+1/(2*gammaA**2))*erfc(farg/np.sqrt(2.)+1./(np.sqrt(2.)*gammaA))

    #High energy tail TB
    TB = amp/(2.*wid*gammaB)*np.exp(-farg/gammaB+1/(2*gammaB**2))*erfc(-farg/np.sqrt(2.)+1./(np.sqrt(2.)*gammaB))

    ppic = np.array(gau+fA*TA+fB*TB)

    return ppic
